\begin{syllabus}

\course{CS2102. Análisis y Diseño de Algoritmos}{Obligatorio}{CS2102}
% Source file: ../Curricula.in/lang/Espanol/cycle/2020-I/Syllabi/Computing/CS/CS212.tex

\begin{justification}
Un algoritmo es, esencialmente, un conjunto bien definido de reglas o instrucciones
que permitan resolver un problema computacional. El estudio teórico del desempeño
de los algoritmos y los recursos utilizados por estos, generalmente tiempo y espacio, 
nos permite evaluar si un algoritmo es adecuado para un resolver un problema 
específico, compararlo con otros algoritmos para el mismo problema o incluso
delimitar la frontera entre lo viable y lo imposible.

Esta materia es tan importante que incluso Donald E. Knuth definió a
Ciencia de la Computación como el estudio de algoritmos.

En este curso serán presentadas las técnicas más comunes utilizadas en el análisis y diseño de 
algoritmos eficientes, con el propósito de aprender los principios fundamentales
del diseño, implementación y análisis de algoritmos para la solución de problemas
computacionales.
\end{justification}

\begin{goals} 
\item Desarrollar la capacidad para evaluar la complejidad y calidad de algoritmos propuestos para un determinado problema.
\item Estudiar los algoritmos más representativos, introductorios de las clases más importantes de problemas tratados en computación.
\item Desarrollar la capacidad de resolución de problemas algorítmicos utilizando los principios fundamentales de diseño de algoritmos aprendidos.
\item Ser capaz de responder a las siguientes preguntas cuando le sea presentado un nuevo algoritmo: ?`Cuán buen desempeño tiene?, ?`Existe una mejor forma de resolver el problema?
\end{goals}

\begin{outcomes}{V1}
    \item \ShowOutcome{a}{3} 
    \item \ShowOutcome{b}{3} 
\end{outcomes}

\begin{outcomes}{V2}
    \item \ShowOutcome{1}{2} 
    \item \ShowOutcome{2}{2} 
\end{outcomes}

\begin{competences}{V1}
    \item \ShowCompetence{C1}{a} 
    \item \ShowCompetence{C2}{b} 
    \item \ShowCompetence{C3}{b} 
    \item \ShowCompetence{C5}{a} 
    \item \ShowCompetence{C6}{a} 
    \item \ShowCompetence{C9}{a} 
\end{competences}

\begin{competences}{V2}
    \item \ShowCompetence{C1}{1} 
    \item \ShowCompetence{C2}{2} 
    \item \ShowCompetence{C3}{2} 
    \item \ShowCompetence{C5}{1} 
    \item \ShowCompetence{C6}{1} 
    \item \ShowCompetence{C9}{2} 
\end{competences}

\begin{unit}{\ALBasicAnalysis}{}{KT2005,DPV2006,CLRS2009,S2013,K1997}{10}{a}
\begin{topics}%
    \item \ALBasicAnalysisTopicDifferences % Diferencias entre el mejor, el esperado y el peor caso de un algoritmo.
    \item \ALBasicAnalysisTopicAsymptotic % Análisis asintótico de complejidad de cotas superior y esperada.
    \item \ALBasicAnalysisTopicComplexity % Clases de complejidad como constante, logarítmica, lineal, cuadrática y exponencial.
    \item Notación asintótica
    \item \ALBasicAnalysisTopicAnalysis % Análisis de algoritmos iterativos y recursivos.
    \item Pruebas inductivas y corrección de algoritmos.
    \item \ALBasicAnalysisTopicSome % Algunas versiones del Teorema Maestro.
\end{topics}
\begin{learningoutcomes}
    \item \ALBasicAnalysisLOExplain [\Assessment] % Explique a que se refiere con ``mejor", ``esperado" y ``peor" caso de comportamiento de un algoritmo.
    \item \ALBasicAnalysisLODetermine [\Assessment] % Determine informalmente el tiempo y el espacio de complejidad de simples algoritmos.
    \item \ALBasicAnalysisLOList [\Assessment] % Lista y contraste de clases estándares de complejidad.
    \item \ALBasicAnalysisLOExplainThe [\Assessment] % Explicar el uso de la notación theta grande, omega grande y o pequeña para describir la cantidad de trabajo hecho por un algoritmo.
    \item Analizar los tiempos de ejecución de algoritmos en el peor de los casos utilizando análisis asintótico [\Assessment]
    \item \ALBasicAnalysisLOUseRecurrence [\Assessment] % Usar relaciones recurrentes para determinar el tiempo de complejidad de algoritmos recursivamente definidos.
    \item \ALBasicAnalysisLOSolve [\Assessment] % Resuelve relaciones de recurrencia básicas, por ejemplo. usando alguna forma del Teorema Maestro.
    \item Discutir la exactitud de los algoritmos utilizando pruebas inductivas [\Assessment]
    [\Assessment]
\end{learningoutcomes}
\end{unit}

\begin{unit}{\ALAlgorithmicStrategies}{}{KT2005,DPV2006,CLRS2009,A1999}{30}{a,b}
\begin{topics}%
    \item \ALAlgorithmicStrategiesTopicBrute % Algoritmos de fuerza bruta.
    \item \ALAlgorithmicStrategiesTopicGreedy % Algoritmos voraces.
    \item \ALAlgorithmicStrategiesTopicDivide % Divide y vencerás.
    \item \ALAlgorithmicStrategiesTopicDynamic % Programación Dinámica.
\end{topics}
\begin{learningoutcomes}
    \item \ALAlgorithmicStrategiesLOFor [\Assessment] % Para cada una de las estrategias (fuerza bruta, algoritmo goloso, divide y vencerás, recursividad en reversa y programación dinámica), identifica un ejemplo práctico en el cual se pueda aplicar.
    \item \ALAlgorithmicStrategiesLOUseA [\Assessment] % Utiliza un enfoque voraz para resolver un problema específico y determina si la regla escogida lo guía a una solución óptima.
    \item \ALAlgorithmicStrategiesLOUseAConquer [\Assessment] % Usa un algoritmo de divide-y-vencerás para resolver un determinado problema.
    \item \ALAlgorithmicStrategiesLOUseDynamic [\Assessment] % Usa programación dinámica para resolver un problema determinado.
    \item \ALAlgorithmicStrategiesLODetermineAn [\Assessment] % Determina el enfoque algorítmico adecuado para un problema.
\end{learningoutcomes}
\end{unit}

\begin{unit}{\ALFundamentalDataStructuresandAlgorithms}{}{KT2005,DPV2006,CLRS2009,S2011,GT2009}{6}{a,b}
\begin{topics}%
    \item \ALFundamentalDataStructuresandAlgorithmsTopicGraphsAnd % "Grafos y algoritmos en grafos:
									      % begin{subtopic} 
										  % \item Algoritmos de la ruta más corta (algoritmos de Dijkstra y Floyd)
										  % \item Árbol de expansión mínima (algoritmos de Prim y Kruskal) 
                                            % end{subtopic}"
    \item Algoritmos no percibidos en caché 
    \item Teoría de números y criptografía
\end{topics}
\begin{learningoutcomes}
    \item \ALFundamentalDataStructuresandAlgorithmsLODiscussFactors [\Familiarity] % Discutir factores otros que no sean eficiencia computacional que influyan en la elección de algoritmos, tales como tiempo de programación, mantenibilidad, y el uso de patrones específicos de la aplicación en los datos de entrada.
    \item \ALFundamentalDataStructuresandAlgorithmsLOSolveProblems [\Assessment] % Resolver problemas usando algoritmos básicos de grafos, incluyendo busqueda por profundidad y busqueda por amplitud.
    \item \ALFundamentalDataStructuresandAlgorithmsLODemonstrate [\Assessment] % Demostrar habilidad para evaluar algoritmos, para seleccionar de un rango de posibles opciones, para proveer una  justificación por esa selección,y para implementar el algoritmo en un contexto en específico.
    \item \ALFundamentalDataStructuresandAlgorithmsLOSolveProblemsAlgorithms [\Assessment] % Resolver problemas usando algoritmos de grafos, incluyendo camino más corto de una sola fuente y camino más corto de todos los pares, y como mínimo un algoritmo de arbol de expansion minima.
\end{learningoutcomes}
\end{unit}

\begin{unit}{\ALBasicAutomataComputabilityandComplexity}{}{KT2005,DPV2006,CLRS2009}{2}{a,b}
\begin{topics}%
    \item \ALBasicAutomataComputabilityandComplexityTopicIntroduction % Introducción a las clases P y NP y al problema P vs. NP.
    \item \ALBasicAutomataComputabilityandComplexityTopicIntroductionTo % Introducción y ejemplos de problemas NP- Completos y a clases NP-Completos.
    \item Reducciones
\end{topics}
\begin{learningoutcomes}
    \item \ALBasicAutomataComputabilityandComplexityLODefine [\Familiarity] % Define las clases P y NP
    \item \ALBasicAutomataComputabilityandComplexityLOExplainTheNp [\Familiarity] % Explique el significado de NP-Completitud
\end{learningoutcomes}
\end{unit}

\begin{unit}{\ALAdvancedDataStructuresAlgorithmsandAnalysis}{}{KT2005,DPV2006,CLRS2009,T1983,R1992}{12}{a,b}
\begin{topics}%
    \item \ALAdvancedDataStructuresAlgorithmsandAnalysisTopicGraphs % Grafos (ej. Ordenamiento Topológico, encontrando componentes puertemente conectados)
    \item \ALAdvancedDataStructuresAlgorithmsandAnalysisTopicRandomized % Algoritmos aleatorios.
    \item \ALAdvancedDataStructuresAlgorithmsandAnalysisTopicAmortized % Análisis amortizado.
    \item \ALAdvancedDataStructuresAlgorithmsandAnalysisTopicProbabilistic % Análisis Probabilístico.
    \item Algoritmos de aproximación
    \item Programación lineal
\end{topics}
\begin{learningoutcomes}
    \item \ALAdvancedDataStructuresAlgorithmsandAnalysisLOUnderstand [\Familiarity]% Entender el mapeamento de problemas del mundo real a soluciones algorítmicas (ejemplo, problemas de grafos, programas lineares,etc)
    \item \ALAdvancedDataStructuresAlgorithmsandAnalysisLOSelect [\Usage] % Seleccionar y aplicar técnicas de algoritmos avanzadas (ejemplo, randonmización, aproximación) para resolver problemas reales.
    \item \ALAdvancedDataStructuresAlgorithmsandAnalysisLOSelectAnd [\Usage] % Seleccionar y aplicar técnicas avanzadas de análisis (ejemplo, amortizado, probabilistico,etc) para algoritmos.
\end{learningoutcomes}
\end{unit}

\begin{coursebibliography}
\bibfile{Computing/CS/CS212}
\end{coursebibliography}

\end{syllabus}
